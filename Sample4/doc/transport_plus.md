# Над-транспортный уровень Transport+

Содержание

[TOC]

## Список терминов и обозначений

Используются следующие термины и обозначения:

- адрес узла - уникальный над-транспортный адрес узла, определенный в рамках над-транспортного уровня и состоящий из трех элементов: NodeID, ip и сокет;
- сокет - интернет сокет для подключения к узлу;
- Broadcast - алгоритм Partition-based Broadcast для сетей p2p на основе Chord;
- ip - интернет IP-адрес узла с поддержкой v4 и v6;
- fingers - таблица связей, содержащая перечень адресов узлов, наполнение таблицы определяется логикой LLChord;
- LLChord - алгоритм Low Latency Chord, улучшение классического алгоритма Chord;
- messageID - уникальный идентификатор сообщения, циркулирующего в p2p сети;
- NodeID - уникальный Chord идентификатор узла в p2p сети. Вычисляется, как результат хэш-функции SHA-1 от строки, состоящей из ip и socket, представленных в виде единой строки;
- p2p сеть - одноранговая сеть (от англ. "peer-to-peer");
- predecessor - адрес предыдущего узла в p2p сети, чей NodeID является численно-ближайшим меньшим к NodeID текущего узла;
- seed - список над-транспортных адресов узлов, корректно функционирующих в p2p сети;
- successor - адрес последующего узла в p2p сети, чей NodeID является численно-ближайшим большим к NodeID текущего узла;
- Transport+ - над-транспортный уровень.

## Назначение над-транспортного уровня

Над-транспортный уровень служит для организации сетевого взаимодействия между узлами одноранговой сети с минимальными задержками и широковещательной рассылкой в условиях ограниченных канальных ресурсов и динамически изменяющейся топологии сети.

## Общая характеристика

### Требования к над-транспортному уровню

Над-транспортный уровень соответствует следующим требованиям современных p2p сетей, а именно:

1. Простота реализации.
2. Простота расширения функционала.
3. Независимость узлов между собой.
4. Децентрализованная территориально распределенная сеть с независимыми между собой узлами.
5. В перспективе неограниченный размер сети. На сегодня – 2500 узлов.
6. Отсутствие выделенных серверов для балансировки информационных потоков.
7. Мерцающая сеть - непрерывно меняющееся количество узлов в сети.
8. Для подключения нового узла требуется знание любого существующего узла.
9. Ограниченный размер таблицы связей узлов между собой – невозможность хранить таблицу связей каждого с каждым в виду значительных накладных расходов на поддержание её актуальной для мерцающей сети.
10. Ограничение производительности и канальных ресурсов у узлов – узел не может единолично рассылать всем сообщения из-за неограниченного размера сети, неприемлемого роста очередей сообщений на отправку, поддерживается лишь ограниченное число интернет сокетов.
11. Доставка сообщений с минимальными задержками.
12. Поддержка гарантированной широковещательной рассылки, обеспечивающая доставку в условиях сбоев и отказов узлов и каналов связи.

### Общая структура над-транспортного уровня

В основе Transport+ лежат следующие алгоритмы:

* **Алгоритм LLChord с модификацией**. LLChord является развитием алгоритма Chord и полностью с ним совместим. LLChord предназначен для уменьшение задержек при пересылке сообщений или поиске узлов в p2p сети на основе Chord. Алгоритм Сhord описывает базовые принципы организации сетевого взаимодействия между узлами в децентрализованной p2p сети. Выполнена модификация LLChord, позволяющая напрямую пересылать сообщение удаленному узлу для уменьшения временных затрат на пересылку сообщений при поиске адресата в сети.
* **Алгоритм Partition-based broadcast (Broadcast) с модификацией**.  Broadcast предназначен для широковещательной рассылки сообщений по p2p сети на основе Chord с единичным посещением каждого узла.

На рис.1 представлены интерфейсы над-транспортного уровня для взаимодействия с уровнем приложений и канальным уровнем ПОБС.

![interfaces](..\doc\pic\interfaces.svg)

Рис.1 - Интерфейсы над-транспортного уровня

Над-транспортный уровень имеет следующие интерфейсы с вышележащим  уровнем приложений:

1. *Интерфейс данных*, отвечающий за передачу и прием данных.
2. *Конфигурационный интерфейс*, использующийся для управления над-транспортным уровнем путём изменения конфигурационных параметров.

Над-транспортный уровень для коммуникаций с нижележащим транспортным уровнем использует *интерфейс данных*, предназначенный для приема и передачи сообщений в транспортный уровень TCP/UDP.

### Машина состояний над-транспортного уровня

Работа Transport+ уровня в общем случае описывается Машиной состояний (МС), представленной в виде конечного детерминированного автоматом на рис. 2.

![finite_state_machine](..\doc\pic\finite_state_machine.svg)

Рис. 2 - Машина состояний Transport+ уровня

Уровень одновременно может находиться только в одном из состояний.  Определены следующие состояния:

- LOAD - начальное состояние, загрузка конфигурационных параметров. 
- INIT - первичная настройка таблицы fingers и таблицы latency.
- JOIN - состояние подключения узла к p2p сети.
- IDLE - рабочее состояние ожидания;
- IN_DATA - состояние обработки сообщения данных, принятого из сети;
- SERVICE - состояние обработку служебных сообщений, использующихся для поддержания целостности p2p сети;
- UPDATE - установка precessor и обновление successor, таблицы fingers и таблицы latency;
- APP_REQUEST - состояние обработки запросов, поступивших от приложения или состояния UPDATE.

Общее описание действий каждого состояний приведено на рис.2.

#### LOAD

После включения Transport+ уровня узел находится в состоянии LOAD. В этом состоянии выполняется загрузка конфигурационных параметров. Таймеры и очереди сброшены, пусты.

#### INIT

В данном состоянии выполняется инициализация и заполнение таблиц связей fingers, successor, predecessor первым адресом узла из seed. Таблица временных задержек latency заполняется значением из конфигурационного параметра Linit. 

#### JOIN

Состояние, в котором устанавливается successor и записи в таблице fingers и latency в количестве 2 штук. 

Отправляется в сеть сообщение c типом "`join`" (далее для краткости фраза "с типом" опускается и не используется).

Взводится таймер t_init на время, определенное в конфигурационном параметре Tinit.

Ожидается приход ответного сообщения `reply_find_successor`, содержащего адрес для successor c временной меткой. На основе временных меток вычисляется временная задержка между текущим  Transport+ уровнями текущего и удаленным узлом.

При отсутствии поступления ответных сообщений и истечения таймаута Tinit выполняется повторная отправка сообщения join.

При превышении количества повторных отправок более Cinit раз сообщение join отправляется узлу, чей адрес указан следующим в списке seed. Если достигнут конец списка seed,  то берется первый адрес из seed и так далее.

Отправляется два сообщения find_successor с id+1 и id+2, где id - собственный идентификатор узла. Каждый раз взводится таймер t_init.

При отсутствии ответных сообщений reply_find_successor отправляется сообщение join на адрес узла, следующего из списка seed, и действия повторяются.

При корректном заполнении successor и таблицы fingers и latency не менее, чем на 2 записи, взводится таймер t_update на длительность, указанную в конфигурационном параметре Tupdate.

#### IDLE

В данном состоянии уровень Transport+ ожидает поступления данных или истечения таймера проверки актуальности (доступности) узлов t_update. Данными  являются: 1) входящие сообщения, поступающие из сети;  2) запросы, приходящие от вышерасположенного уровня приложения (далее - приложения). 

При поступлении входящего сообщения оно **проверяется на корректность**, а именно проверяется допустимость сочетания численных значений полей сообщения в зависимости от типа сообщения,  соответствие адреса получателя адресу текущего узла.

Также проверяется поступало ли такое сообщение ранее. Для этого каждое сообщение идентифицируется по временной метке и **подсчитывается количество получений** такого сообщения. Если количество превышает допустимое, определенное в конфигурационном параметре Crecv в течение времени Trecv, то сообщение отбрасывается.

#### IN_DATA

Состояние обработки информационного сообщения `single` или `broadcast`, принятого из p2p сети. Выполняются следующие действия:

1. Отправка подтверждения получения `ack`;
3. Передать данных из сообщения в приложению, если адресат сообщения соответствует собственному адресу узла;
4. При необходимости переслать сообщение далее по сети по логике LLChord или Broadcast с ожиданием подтверждения `ack` в течение таймаута Tack.

#### SERVICE

Состояние обработки служебных сообщений, принятых из p2p сети.

Обрабатываются следующие сообщения:

- `join`

- `find_successor`

  

#### APP_REQUEST

Состояние обработки запроса, поступившего от приложения или из состояния HANDLE_MESSAGE. В зависимости от типа запроса выполняются различные действия, а именно:

- **req_hard_reset** - выполняется сброс очередей, таймеров, таблицы fingers и таблицы latency, переход в состояние LOAD;
- **req_soft_reset** - выполняется сброс таблицы fingers и таблицы latency, при этом сохраняются очереди и таймеры, переход в состояние INIT;
- **req_flush** - осуществляется сброс очередей, таймеров, при этом сохраняются таблица fingers и таблица latency, переход в состояние IDLE;
- **req_single** - формируется и отправляется сообщение `single_message`с ожиданием прихода подтверждения ack в течение таймаута Tack;
- **req_broadcast** - формируется и отправляется сообщение `broadcast_message` с ожиданием прихода подтверждения ack в течение таймаута Tack.



#### UPDATE

Состояние корректировки таблицы fingers, successor, predecessor и таблицы latency.

Обрабатываются следующие сообщения:

- `notify`

- `reply_find_successor`

  

### Таймеры

todo

### Конфигурационные параметры

В Transport+ используются конфигурационные параметры, представленные в таблице 1. Значения параметров должны быть определены до включения узла.

Таблица 1. Конфигурационные параметры уровня Transport+

| Параметр | Назначение                                                   | Значение по умолчанию |
| -------- | ------------------------------------------------------------ | --------------------- |
| seed     | список над-транспортных адресов узлов, корректно функционирующих в p2p сети | Минимум адрес узла    |
| Linit    | значение по умолчанию временной задержки между узлами на Transport+ уровне | 0,001 сек             |
| Tinit    | таймаут ожидания прихода сообщений reply_find_succesor для fingers, successor, predeccessor | 20 сек                |
| Cinit    | счетчик допустимого количества повторных отправок сообщений join | 3                     |
| Tupdate  | таймаут проверки актуальности записи адреса узла в таблице fingers, successor, predecessor и соответствующей им временной задержки в таблице latency | 5 сек                 |
| Tack     | таймаут ожидания прихода сообщения подтверждения ack         | 30 сек                |
| Crecv    | Счетчик допустимого количества получения дублированных сообщений | 2                     |
| Trecv    | Таймаут в течение, которого разрешено получать и обрабатывать дублированное сообщение | 25 сек                |
|          |                                                              |                       |
|          |                                                              |                       |
|          |                                                              |                       |



### Типы сообщений

В Transport+ уровне определены и используются следующие типы сообщений:

служебные сообщения:

- join
- notify;

- find_successor;
- reply_find_successor;
- ack;
- single;
- broadcast.





### Форматы сообщений

**TODO** сообщение **find_successor** служит для ...

Состоит из следующих полей:

- dest - адрес узла назначения;
- source - адрес узла отправителя;
- initiator - адрес узла,  первоначально запустившего по сети запрос;
- type - тип запроса. Принимает значение "find_successor";
- данные - поле данных. Содержит искомый id узла;
- issued time - время создания запроса.



Сообщение **reply_find_successor**  служит для ...

Состоит из следующих полей:

- dest - адрес узла назначения;
- source - адрес узла отправителя;
- type - тип запроса. Принимает значение "reply_find_successor".
- данные - поле данных. Содержит адрес искомого узла в виде структуры под названием successor_address с полями: {ip, socket, id}
- issued time - время создания запроса



### Архитектура модели над-транспортного уровня

Общая архитектура внутренних взаимосвязей Transport+ уровня в виде цепочки вызовов программных функций проиллюстрирован на рис. 3.

![arch](..\doc\pic\arch.svg)



### Обработка служебных сообщений

todo

###### join

После получения сообщения `join`, содержащим адрес нового узла в поле `data`, узел проверяет свою таблицу fingers, successor и predecessor на соответствие какой адрес из известных узлов может выступать в роли successor, predecessor, finger_table для нового узла (полный комплект информации, требующейся новому узлу в состоянии **IDLE**) . Если имеются адреса таких узлов, то формируется запрос на отправку сообщение (-я) `reply_find_successor`. В запросе указывается адрес искомого узла, включая id, ip и сокет.  Корректируется собственная таблица fingers для занесения адреса нового узла при необходимости.

В противном случае узел формирует ==серию== запросов для отправки сообщений `find_successor` с указанием искомого адреса в поле data. Рассылка выполняется для тех адресов из полного комплекта информации, для которых не было найдена запись внутри текущего узла.

###### find_successor

После получения сообщения `find_successor`, содержащим id искомого узла в поле `data`,  узел проверяет свою таблицу fingers, successor и predecessor на наличие сведений о том, какой из известных узлов соответствует искомому. Если есть такой узел, то в ответ формируется запрос на выдачу сообщения `reply_find_successor` c указанием адреса искомого узла, включая id, ip и сокет. 

В противном случае узел шлет формирует запрос на отправку сообщения `find_successor` с искомым id в сеть по логике LLChord.

###### reply_find_successor

После получения сообщения `reply_find_successor`, содержащим адрес найденного узла и адрес искомого узла в поле `data`, в таблицу fingers, precessor или successor вносится новый запись с указанием id узла, ip и сокета. На основании размера сообщения, временной метки сообщения, времени отправления исходного сообщения (`join` или `find_successor`) вычисляется временная задержка и заносится в таблицу latency.

### Обработка информационных сообщений

todo

###### single

После получения сообщения `single` с адресом назначения, принадлежащему текущему узлу, данные из поля `data` извлекаются и передаются приложению. Если адрес узла назначения не равен текущему адресу узлу, то формируется запрос на отправку сообщения `single_message` в p2p сеть.

###### broadcast

После получения сообщения `broadcast`  данные из поля `data` извлекаются и передаются приложению. Если по логике алгоритма Broadcast требуется продолжить широковещательную рассылку, то формируется запрос `req_broadcast` на отправку сообщения `broadcast` в p2p сеть.


​	    	  




# Над-транспортный уровень Transport+

## 

## Назначение над-транспортного уровня

Над-транспортный уровень (далее - Transport+) служит для организации сетевого взаимодействия между узлами p2p (от англ. "peer-to-peer", одноранговой) сети с минимальными задержками и широковещательной рассылкой в условиях ограниченных канальных ресурсов.

## Общая характеристика

### Требования к над-транспортному уровню

Над-транспортный уровень соответствует следующим требованиям современных p2p сетей, а именно:

1. Простота реализации.
2. Простота расширения функционала.
3. Независимость узлов между собой.
4. Децентрализованная территориально распределенная сеть с независимыми между собой узлами.
5. В перспективе неограниченный размер сети. На сегодня – 2500 узлов.
6. Отсутствие выделенных серверов для балансировки информационных потоков.
7. Мерцающая сеть - непрерывно меняющееся количество узлов в сети.
8. Для подключения нового узла требуется знание любого существующего узла.
9. Ограниченный размер таблицы связей узлов между собой – невозможность хранить таблицу связей каждого с каждым в виду значительных накладных расходов на поддержание её актуальной для мерцающей сети.
10. Ограничение производительности и канальных ресурсов у узлов – узел не может единолично рассылать всем сообщения из-за неограниченного размера сети, неприемлемого роста очередей сообщений на отправку, поддерживается лишь ограниченное число интернет сокетов.
11. Доставка сообщений с минимальными задержками.
12. Поддержка гарантированной широковещательной рассылки, обеспечивающая доставку в условиях сбоев и отказов узлов и каналов связи.

### Общая структура над-транспортного уровня

В основе Transport+ лежат следующие алгоритмы:

* **Алгоритм Low Latency Chord (LLChord) с модификацией**. LLChord является развитием алгоритма Chord и полностью с ним совместим. LLChord предназначен для уменьшение задержек при пересылке сообщений или поиске узлов в p2p сети на основе Chord. Алгоритм Сhord описывает базовые принципы организации сетевого взаимодействия между узлами в децентрализованной p2p сети. Выполнена модификация LLChord, позволяющая напрямую пересылать сообщение удаленному узлу для уменьшения временных затрат на пересылку сообщений при поиске адресата в сети.

* **Алгоритм Partition-based broadcast (Broadcast) с модификацией**.  Broadcast предназначен для широковещательной рассылки сообщений по p2p сети на основе Chord с единичным посещением каждого узла.

  ==Заметка.==

  Пока открыт вопрос - Костя предложил начать с штатных средств поддержания сети связанной. Для этого используется механизм обновления таблиц связей (далее - fingers), описанный в Chord в виде псевдокода stabilize и fix_fingers. В этом случае модификация не требуется. Однако перестройка, обновление fingers требует времени. Надо промоделировать оценить каково будет максимальные время распространения сообщения по сети, если сети приходится перестраиваться при каждой передаче сообщения (100%), при 90%, 75%, 50%, 25%, 15%, 10%, 5%.
  
  Мое предложение (Ильи) - сделать модификацию Broadcast, а именно ввести обмен между узлами короткими подтверждающими сообщениями, что узел широковещательно переслал сообщение дальше по сети, а также расширить fix_fingers. Это позволит при отказавшем или ушедшем из сети узле гарантированно продолжить широковещательную рассылку, не дожидаясь того, как сеть сама перестроится, обновит fingers. Для этого требуется увеличить размер fingers с log~2~(N) до 2 log~2~(N). Тогда сеть сможет продолжить широковещание лишь по одной части сети, а для второй части сети потребуется дождаться обновления fingers. Другой мною предлагаемый вариант -  расширить fingers таким образом, чтобы полностью хранить fingers своих соседей в узле, т.е. размер fingers вырастет до *(log~2~(N))^2^*. В этом случае без задержек можно будет продолжить широковещание при отказавшем узле.

### Алгоритм LLChord c модификацией

Работа p2p сети на основе LLChord состоит из следующих действий:

* добавление узла в сеть.
* поиск successor.
* стабилизация fingers.
* отправка.
* прием.

#### Добавление узла в сеть

Выполняются следующие шаги:

- начальная инициализация узла (initialisation)
- стабилизация таблицы связей fingers (stabilisation)

initialisation вызывается только один раз.

При инициализации узла Задается

```С++
initialisation(exist_node, _ip, _socket, _period)	
	myAddress.ip = _ip                 //IP-адрес в виде строки. Узел изначально знает свой IP-адрес
	myAddress.socket = _socket         //узел изначально знает номер сокета для отправки и приема сообщений
	myAddress.id = sha_1(_ip, _socket) //вычисляется ID узла как SHA-1 от IP-адреса узла и номера сокета
	predecessor = nill
	successor = nill
	period = _period                   //сохранить значение периода вызова стабилизации во внутр переменную
	fingerSize = 14                    //максимальный размер сети - 16384 узлов, log(16384) = 14
	Цикл i c 0 по fingerSize-1           //инициализация fingers изначально пустыми значениями      	
		finger[i].ip = nil
	Если exist_node != nill   
	    stabilisation()	    
```

stabilisation осуществляет опрос (пинг) узлов из таблицы fingers, predecessor и successor. Если fingers,  predecessor и successor не были ранее определены или не отвечают на пинг, то выполняется их заполнение.

	stabilisation()
		Если exist_node == nill 
		    exit
		Если successor == nill
			цикл три попытки
				отправка к exist_node запроса find_successor c параметром myAddress.id+1	
				ожидание прихода ответа 20 сек.
			Если exist_node не отвечает
	
	
		Если predecessor == nill
			цикл три попытки
				отправка к exist_node запроса find_successor c параметром myAddress.id-1	
				ожидание прихода ответа 20 сек.
			
		finger[0] = successor
	    Цикл i c 1 по fingerSize-1
	    	Если finger[i].ip = nill
	    	то отправить запрос find_successor(myAddress.id+pow(2,i)) к exist_node
	    	
	    	
	    	  




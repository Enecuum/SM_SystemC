# Над-транспортный уровень Transport+

Содержание

[TOC]

## Список терминов и обозначений

Используются следующие термины и обозначения:

- адрес узла - уникальный над-транспортный адрес узла, определенный в рамках над-транспортного уровня и состоящий из трех элементов: NodeID, ip и сокет;
- сокет - интернет сокет для подключения к узлу;
- Broadcast - алгоритм Partition-based Broadcast для сетей p2p на основе Chord;
- ip - интернет IP-адрес узла с поддержкой v4 и v6;
- fingers - таблица связей, содержащая перечень адресов узлов, наполнение таблицы определяется логикой LLChord;
- LLChord - алгоритм Low Latency Chord, улучшение классического алгоритма Chord;
- messageID - уникальный идентификатор сообщения, циркулирующего в p2p сети;
- NodeID - уникальный Chord идентификатор узла в p2p сети. Вычисляется, как результат хэш-функции SHA-1 от строки, состоящей из ip и socket, представленных в виде единой строки;
- p2p сеть - одноранговая сеть (от англ. "peer-to-peer");
- predecessor - адрес предыдущего узла в p2p сети, чей NodeID является численно-ближайшим меньшим к NodeID текущего узла;
- seed - список над-транспортных адресов узлов, корректно функционирующих в p2p сети;
- successor - адрес последующего узла в p2p сети, чей NodeID является численно-ближайшим большим к NodeID текущего узла;
- Transport+ - над-транспортный уровень.

## Назначение над-транспортного уровня

Над-транспортный уровень служит для организации сетевого взаимодействия между узлами одноранговой сети с минимальными задержками и широковещательной рассылкой в условиях ограниченных канальных ресурсов и динамически изменяющейся топологии сети.

## Общая характеристика

### Требования к над-транспортному уровню

Над-транспортный уровень соответствует следующим требованиям современных p2p сетей, а именно:

1. Простота реализации.
2. Простота расширения функционала.
3. Независимость узлов между собой.
4. Децентрализованная территориально распределенная сеть с независимыми между собой узлами.
5. В перспективе неограниченный размер сети. На сегодня – 2500 узлов.
6. Отсутствие выделенных серверов для балансировки информационных потоков.
7. Мерцающая сеть - непрерывно меняющееся количество узлов в сети.
8. Для подключения нового узла требуется знание любого существующего узла.
9. Ограниченный размер таблицы связей узлов между собой – невозможность хранить таблицу связей каждого с каждым в виду значительных накладных расходов на поддержание её актуальной для мерцающей сети.
10. Ограничение производительности и канальных ресурсов у узлов – узел не может единолично рассылать всем сообщения из-за неограниченного размера сети, неприемлемого роста очередей сообщений на отправку, поддерживается лишь ограниченное число интернет сокетов.
11. Доставка сообщений с минимальными задержками.
12. Поддержка гарантированной широковещательной рассылки, обеспечивающая доставку в условиях сбоев и отказов узлов и каналов связи.

### Общая структура над-транспортного уровня

В основе Transport+ лежат следующие алгоритмы:

* **Алгоритм LLChord с модификацией**. LLChord является развитием алгоритма Chord и полностью с ним совместим. LLChord предназначен для уменьшение задержек при пересылке сообщений или поиске узлов в p2p сети на основе Chord. Алгоритм Сhord описывает базовые принципы организации сетевого взаимодействия между узлами в децентрализованной p2p сети. Выполнена модификация LLChord, позволяющая напрямую пересылать сообщение удаленному узлу для уменьшения временных затрат на пересылку сообщений при поиске адресата в сети.
* **Алгоритм Partition-based broadcast (Broadcast) с модификацией**.  Broadcast предназначен для широковещательной рассылки сообщений по p2p сети на основе Chord с единичным посещением каждого узла.

На рис.1 представлены интерфейсы над-транспортного уровня для взаимодействия с уровнем приложений и канальным уровнем ПОБС.

![interfaces](..\doc\pic\interfaces.svg)

Рис.1 - Интерфейсы над-транспортного уровня

Над-транспортный уровень имеет следующие интерфейсы с вышележащим  уровнем приложений:

1. *Интерфейс данных*, отвечающий за передачу и прием данных.
2. *Конфигурационный интерфейс*, использующийся для управления над-транспортным уровнем путём изменения конфигурационных параметров.

Над-транспортный уровень для коммуникаций с нижележащим транспортным уровнем использует *интерфейс данных*, предназначенный для приема и передачи сообщений в транспортный уровень TCP/UDP.

### Машина состояний над-транспортного уровня

Работа Transport+ уровня в общем случае описывается конечным детерминированным автоматом, представленном на рис. 2.

![_chord_аlgo](..\doc\pic\_chord_аlgo.svg)

Рис. 2 - Машина состояний Transport+ уровня

Уровень одновременно может находиться только в одном из состояний.  Определены следующие состояния:

- LOAD - начальное состояние, загрузка конфигурационных параметров. 
- INIT - первичная настройка таблицы fingers и таблицы latency.
- JOIN - состояние подключения узла к p2p сети.
- IDLE - рабочее состояние ожидания;
- IN_DATA - состояние обработки сообщения данных, принятого из сети;
- SERVICE - состояние обработку служебных сообщений, использующихся для поддержания целостности p2p сети;
- UPDATE - установка precessor и обновление successor, таблицы fingers и таблицы latency;
- APP_REQUEST - состояние обработки запросов, поступивших от приложения или состояния UPDATE.

Общее описание действий в каждом из состояний приведено на рис.2.

#### INIT

В данном состоянии выполняется инициализация и заполнение таблиц связей fingers, successor, predecessor первым адресом узла из seed. Таблица временных задержек latency заполняется L~init~. 

#### JOIN

Устанавливается successor и записи в таблице fingers и latency в количестве 2 штук. Для этого отправляется в сеть сообщение c типом "`join`" (далее для краткости фраза "с типом" опускается и не используется).

Взводится таймер t~init~ на время, определенное в конфигурационном параметре T~init~. Ожидается приход ==серии== ответных сообщений `reply_find_successor`, содержащих в полях сообщения адреса для fingers и successor c временными метками. На основе временных меток вычисляется временная задержка между текущим  Transport+ уровнями текущего и удаленными узлами.

При отсутствии поступления ответных сообщений и истечения таймаута T~init~ выполняется повторная отправка сообщения join. При превышении количества повторных отправок более C~init~ раз сообщение join отправляется узлу, чей адрес указан следующим в списке seed. Если достигнут конец списка seed,  то берется первый адрес из seed и так далее.

При корректном заполнении successor и таблицы fingers и latency не менее, чем на 2 записи, взводится таймеры t~update~ на длительность, указанную в конфигурационном параметре T~update~.

#### IDLE

В данном состоянии уровень Transport+ ожидает поступления данных для обработки или истечения таймера проверки доступности узлов. Данными для обработки являются: 1) входящие сообщения, поступающие из сети;  2) запросы, приходящие от вышерасположенного уровня приложения (далее - приложения). 

#### HANDLE_MESSAGE

Состояние обработки сообщения, принятого из нижерасположенного транспортного уровня p2p сети. Выполняются следующие действия:

1. Проверка сообщения на корректность;
2. Обработка сообщения;
3. При необходимости формирование запроса на выдачу ответного сообщения или пересылку текущего.

При **проверке сообщения на корректность** проверяется допустимость сочетания численных значений полей сообщения в зависимости от типа сообщения,  соответствие адреса получателя адресу текущего узла и соответствие типа сообщения, ожидаемому для получения по логике уровня Transport+. Также проверяется поступало ли такое сообщение ранее. Для этого подсчитывается и сохраняется количество раз получения сообщения с messageID. Если количество превышает допустимое, определенное в конфигурационном параметре C~recv~ в течение времени T~recv~, то сообщение отбрасывается.

**Обработка сообщения** подразумевает выполнение последовательности действий в зависимости от типа принятого сообщения. Описание приведено ниже.

##### Обработка служебных сообщений с требованием выдачи ответа

###### join

После получения сообщения `join`, содержащим адрес нового узла в поле `data`, узел проверяет свою таблицу fingers, successor и predecessor на соответствие какой адрес из известных узлов может выступать в роли successor, predecessor, finger_table для нового узла (полный комплект информации, требующейся новому узлу в состоянии **IDLE**) . Если имеются адреса таких узлов, то формируется запрос на отправку сообщение (-я) `reply_find_successor`. В запросе указывается адрес искомого узла, включая id, ip и сокет.  Корректируется собственная таблица fingers для занесения адреса нового узла при необходимости.

В противном случае узел формирует ==серию== запросов для отправки сообщений `find_successor` с указанием искомого адреса в поле data. Рассылка выполняется для тех адресов из полного комплекта информации, для которых не было найдена запись внутри текущего узла.

###### find_successor

После получения сообщения `find_successor`, содержащим id искомого узла в поле `data`,  узел проверяет свою таблицу fingers, successor и predecessor на наличие сведений о том, какой из известных узлов соответствует искомому. Если есть такой узел, то в ответ формируется запрос на выдачу сообщения `reply_find_successor` c указанием адреса искомого узла, включая id, ip и сокет. 

В противном случае узел шлет формирует запрос на отправку сообщения `find_successor` с искомым id в сеть по логике LLChord.

###### ping

После получения сообщения `ping` узел в ответ формирует запрос на отправку сообщение `reply_ping`. 

##### Обработка служебных сообщений не требующих ответа

###### reply_find_successor

После получения сообщения `reply_find_successor`, содержащим адрес найденного узла и адрес искомого узла в поле `data`, в таблицу fingers, precessor или successor вносится новый запись с указанием id узла, ip и сокета. На основании размера сообщения, временной метки сообщения, времени отправления исходного сообщения (`join` или `find_successor`) вычисляется временная задержка и заносится в таблицу latency.

###### reply_ping

После получения сообщения `reply_ping` вычисляется временная задержка и заносится в таблицу latency.

##### Обработка информационных сообщений

###### single

После получения сообщения `single` с адресом назначения, принадлежащему текущему узлу, данные из поля `data` извлекаются и передаются приложению. Если адрес узла назначения не равен текущему адресу узлу, то формируется запрос на отправку сообщения `single_message` в p2p сеть.

###### broadcast

После получения сообщения `broadcast`  данные из поля `data` извлекаются и передаются приложению. Если по логике алгоритма Broadcast требуется продолжить широковещательную рассылку, то формируется запрос `req_broadcast` на отправку сообщения `broadcast` в p2p сеть.

#### HANDLE_REQUEST

Состояние обработки запроса, поступившего от приложения или из состояния HANDLE_MESSAGE. В зависимости от типа запроса выполняются различные действия, а именно:

- **req_flush** - осуществляется сброс всех очередей, таймеров и таблицы latency, при этом таблица fingers не сбрасывается, переход в состояние IDLE;
- **req_reset** - выполняется сброс всех очередей, таймеров, таблицы latency и таблицы fingers, переход в состояние INIT;
- **req_single** - формируется сообщение `single_message`, переход в состояние TRANSMIT;
- **req_broadcast** - формируется сообщение `broadcast_message`, переход в состояние TRANSMIT;

#### TRANSMIT

Состояние отправки сообщения в сеть с проверкой доступности удаленного узла.

#### STABILIZE

Состояние корректировки таблицы fingers, successor, predecessor и таблицы latency.

### Таймеры

### Конфигурационные параметры

В Transport+ используются конфигурационные параметры, представленные в таблице 1. Значения параметров должны быть определены до включения узла.

Таблица 1. Конфигурационные параметры уровня Transport+

| Параметр  | Назначение                                                   | Значение по умолчанию |
| --------- | ------------------------------------------------------------ | --------------------- |
| seed      | список над-транспортных адресов узлов, корректно функционирующих в p2p сети | Минимум адрес узла    |
| L~init~   | значение по умолчанию временной задержки между узлами на Transport+ уровне | 0,001 сек             |
| T~init~   | таймаут ожидания прихода сообщений reply_find_succesor для fingers, successor, predeccessor | 20 сек                |
| C~init~   | счетчик допустимого количества повторных отправок сообщений join | 3                     |
| T~update~ | таймаут проверки актуальности записи адреса узла в таблице fingers, successor, predecessor и соответствующей им временной задержки в таблице latency | 5 сек                 |
| T~ack~    | таймаут ожидания прихода сообщения подтверждения ack         | 30 сек                |
| C~recv~   | Счетчик допустимого количества получения дублированных сообщений | 2                     |
| T~recv~   | Таймаут разрешенного получения дублированных сообщений       | 20 сек                |
|           |                                                              |                       |
|           |                                                              |                       |
|           |                                                              |                       |







### Форматы сообщений

**TODO** сообщение **find_successor** служит для ...

Состоит из следующих полей:

- dest - адрес узла назначения;
- source - адрес узла отправителя;
- initiator - адрес узла,  первоначально запустившего по сети запрос;
- type - тип запроса. Принимает значение "find_successor";
- данные - поле данных. Содержит искомый id узла;
- issued time - время создания запроса.



Сообщение **reply_find_successor**  служит для ...

Состоит из следующих полей:

- dest - адрес узла назначения;
- source - адрес узла отправителя;
- type - тип запроса. Принимает значение "reply_find_successor".
- данные - поле данных. Содержит адрес искомого узла в виде структуры под названием successor_address с полями: {ip, socket, id}
- issued time - время создания запроса






​	    	  



